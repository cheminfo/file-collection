import {
  BlobWriter,
  TextReader,
  Uint8ArrayWriter,
  ZipWriter,
} from '@zip.js/zip.js';
import { describe, expect, it, test } from 'vitest';

import { isZip } from '../zip.ts';

describe('valid zip', () => {
  it('should validate normal zip', async () => {
    const zipWriter = new ZipWriter(new BlobWriter());
    await zipWriter.add('hello.txt', new TextReader('Hello World!'));
    const blob = await zipWriter.close();
    const buffer = await blob.arrayBuffer();

    // ensures isZip supports empty zip
    expect(isZip(buffer)).toBe(true);
  });

  it('should validate empty zip', async () => {
    const zipWriter = new ZipWriter(new BlobWriter());
    const blob = await zipWriter.close();
    const buffer = await blob.arrayBuffer();

    const view = new DataView(buffer);
    const [third, fourth] = [view.getUint8(2), view.getUint8(3)];

    // ensures zip js produce "empty zip" signature
    expect(third).toBe(0x05);
    expect(fourth).toBe(0x06);
    // ensures isZip supports empty zip
    expect(isZip(buffer)).toBe(true);
  });

  it('should validate spanned zip', async () => {
    const spanZipWriter = new ZipWriter(new Uint8ArrayWriter());
    await spanZipWriter.add('hello.txt', new TextReader('Hello World!'));
    const spanBuffer = await spanZipWriter.close();

    // I did not find how to create a spanned zip with zip.js,
    // so I simulate the span manually.
    spanBuffer[2] = 0x07;
    spanBuffer[3] = 0x08;

    const blob = new Blob([spanBuffer], { type: 'application/zip' });

    expect(isZip(await blob.arrayBuffer())).toBe(true);
  });
});

describe('invalid zip', () => {
  const invalidSignatures = [
    [
      0x50, 0x4b, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],
    [
      0x50, 0x4b, 0x03, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],
    [
      0x50, 0x4b, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],
    [
      0x50, 0x4b, 0x03, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],

    [
      0x50, 0x4b, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],
    [
      0x50, 0x4b, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],
    [
      0x50, 0x4b, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],
    [
      0x50, 0x4b, 0x05, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],

    [
      0x50, 0x4b, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],
    [
      0x50, 0x4b, 0x07, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],
    [
      0x50, 0x4b, 0x07, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],
    [
      0x50, 0x4b, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ],
  ];

  // it seems eslint does not support `it.for` `test.for`

  // eslint-disable-next-line vitest/require-hook
  test.for(invalidSignatures)(
    'should not valid %i %i %i %i ... (invalid signature)',
    async (array) => {
      const buffer = Uint8Array.from(array);
      const blob = new Blob([buffer], { type: 'application/zip' });

      // eslint-disable-next-line vitest/no-standalone-expect
      expect(isZip(await blob.arrayBuffer())).toBe(false);
    },
  );

  const invalidBySize = [
    [0x50, 0x4b, 0x03, 0x04],
    [0x50, 0x4b, 0x05, 0x06],
    [0x50, 0x4b, 0x07, 0x08],
  ];

  // eslint-disable-next-line vitest/require-hook
  test.for(invalidBySize)(
    'should not valid %i %i %i %i (invalid size)',
    async (array) => {
      const buffer = Uint8Array.from(array);
      const blob = new Blob([buffer], { type: 'application/zip' });

      // eslint-disable-next-line vitest/no-standalone-expect
      expect(isZip(await blob.arrayBuffer())).toBe(false);
    },
  );
});
